#+PROPERTY: tangle no
#+PROPERTY: cache no
#+PROPERTY: session yes
#+PROPERTY: results silent
#+PROPERTY: no-expand yes
#+PROPERTY: noweb yes
#+PROPERTY: exports code
#+PROPERTY: padline yes
Lisp Intercom

this document describes the intercom system from the lisp side.  this contains the description of how to send and receive documents from the client and how to handle them.

* prerequisites
intercom assumes the existence of hunchentoot and of jsown for communication with the clients.  it publishes two paths to handle the communication.

#+begin_src lisp :tangle intercom.asd
  (asdf:defsystem :intercom
    :name "Intercom"
    :author "Aad Versteden <aad@knowified.com>"
    :author "Karel Kremer <karel@knowified.com>"
    :version "0.0.1"
    :maintainer "Aad Versteden <aad@knowified.com>"
    :licence "MIT"
    :description "Intercom allows bidirectional message passing between javascript and lisp."
    :depends-on (jsown hunchentoot bordeaux-threads split-sequence alexandria)
    :serial t
    :components ((:file "packages")
                 (:file "intercom")))
#+end_src

* package specification
intercom is simple and consists of one package which exports everything.  we didn't opt for a special separate package for the implementation due to the limited amount of exported constructs.

#+begin_src lisp :tangle packages.lisp
  (defpackage :intercom
    (:use :cl :jsown :alexandria)
    (:export :define-remote-procedure
             :message :activep
             :*remote-procedure-context* :*hydra-head-timeout* :*hydra-body-timeout*
             ;;---? should with-session-db-lock and with-screen-db-lock be exported too?
             :screen-var :session-var))
#+end_src

* generic functions
:PROPERTIES:
:noweb-ref: generic-functions
:END:
generic functions are best defined at the top of the lisp file.  we define the generic functions here, but implement them in the relevant sections.

#+begin_src lisp
  (defgeneric touch (object)
    (:documentation "touches an object, updating the modification time."))
#+end_src

* data structures
:PROPERTIES:
:noweb-ref: data-structures
:END:

most of the information about the threads is stored in the user's session.  the datastructures and the operations which can occur on them are described in this section.

** parameters
we define the parameters separately, this makes it clear what all the relevant parameters are.

#+begin_src lisp
  (defparameter *remote-procedures* (make-hash-table :test 'equal :synchronized t)
    "contains all intercom remote procedures, the keywords being the matched string and the values being the corresponding function.")
  
  (defparameter *rid* nil
    "variable which contains the request id in functions which represent the execution of a remote procedure.")
  
  (defparameter *hydra-body* nil
    "contains the hydra-body once we have a hydra-body in the current request")
  
  (defparameter *hydra-head* nil
    "contains the hydra-head once we have one in the current request")
  
  (defparameter *hydra-head-id* nil
    "represents the screen identifier of the current request")
  
  (defparameter *hydra-head-timeout* 600
    "the time we have before we assume the head is detached.")
  
  (defparameter *hydra-body-timeout* 86400
    "the time we have before we assume the session has ended.")
  
  (defparameter *hydra-auth-store* (make-hash-table :test 'equal)
    "a hash-table linking each \"hydra\" cookie value to the authentication which belongs to it.")
  
  (defparameter *hydra-auth-lock* (bordeaux-threads:make-lock "hydra-auth-lock")
    "this lock is used when accessing the hydra-auth-store")
#+end_src

** user session
the session of the user will be contacted on various occasions, in multiple threads.  therefore, we create a function which creates the session and -if necessary- populates it with a lock which should be held when modifying the variables in the session.  some sugar is added to manage the session locks in the macro with-local-screen-lock.

#+begin_src lisp
  (defmacro with-session-db-lock ((&optional (session '*hydra-body*)) &body body)
    "executes <body> with a lock on the datastore of hydra-body.
      this should be used when the new value is based on previous values in the session."
    `(with-key-value-store-lock (hydra-body-data ,session)
       ,@body))
  
  (defmacro with-screen-db-lock ((&optional (session '*hydra-head*)) &body body)
    "executes <body> with a lock on the datastore of hydra-head.
        this should be used when the new value is based on previous values in the session."
    `(with-key-value-store-lock (hydra-head-data ,session)
       ,@body))
  
  (defmacro with-local-screen-lock ((protection-symbol) &body body)
    "executes <body> in a piece of code in which the head's data is locked"
    `(progn
       (assert-session)
       (macrolet ((,protection-symbol (&body body)
                    `(with-screen-db-lock ()
                       ,@body)))
         ,@body)))
  
  (defmacro in-intercom-session (&body body)
    "executes a hunchentoot request in an environment in which the special local variables are
    bound to be special and local.
    this contains:
    - *hydra-body*
    - *hydra-head*
    - *hydra-head-id*"
    `(let (*hydra-body* *hydra-head* *hydra-head-id*)
       ,@body))
  
  (defun assert-session ()
    "asserts that we're currently running in an environment which is sane for intercom requests/executions"
    (assert-hydra-body *hydra-body*)
    (assert-hydra-head *hydra-head*))
#+end_src

** remote procedures
a remote procedure connects a string to a function to be called when a request is received to call the function with that name.  call-remote-procedure abstracts between the definition with strings or with symbols.

#+begin_src lisp
  (defun register-remote-procedure (name function)
    "registers the remote procedure for <name> to be <function>."
    (when (gethash name *remote-procedures*)
      (warn "overwriting remote procedure for ~A" name))
    (setf (gethash name *remote-procedures*) function))
  
  (defun get-remote-procedure (name)
    "returns the remote procedure for <name> or nil if the procedure doesn't exist."
    (gethash name *remote-procedures*))
  
  (defparameter *remote-procedure-context* nil
    "should contain an alist in which the keywords are special variables and the values
     are evaluated (in the creating thread) each time a remote procedure is built.
     this allows you to pass special variables.")
  
  (defun thread-initial-bindings ()
    "calculates the initial bindings for the current thread.  this consists of whatever
     is available in bordeaux-threads:*initial-bindings*, but with what
     *remote-procedure* contains in front of it (in which the values are evaluated)."
    (concatenate 'list
                 (loop for (k . v) in *remote-procedure-context*
                    collect (cons k (eval v)))
                 bordeaux-threads:*default-special-bindings*))
  
  (defun call-remote-procedure (rid name &rest args)
    "calls the remote prodecure with name <name> and <args> as the arguments with <rid> as reference.  assumes the special variable *store* exists"
    (assert (get-remote-procedure name))
    (bordeaux-threads:make-thread
     (let ((hydra-body *hydra-body*)
           (hydra-head *hydra-head*))
       (lambda ()
         (let ((*hydra-body* hydra-body)
               (*hydra-head* hydra-head)
               (*rid* rid))
           (start-rid *rid*)
           (unwind-protect
                (apply (get-remote-procedure name) args)
             (with-local-screen-lock (!)
               (push rid (screen-var 'rids-to-end)))))))
     :initial-bindings (thread-initial-bindings)
     :name name))
#+end_src

some syntactic sugar to define remote procedures is obviously welcome.  this is handled in the following piece of code.

#+begin_src lisp
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun make-remote-procedure-lambda-function (arguments body)
      "builds the s-expression representation for the lambda function which can be called for the definition of a remote procedure.  this handles the creation of the &key arguments."
      (let* ((arguments (split-sequence:split-sequence '&key arguments))
             (symbols (loop repeat (1- (length arguments)) collect (gensym "jsown-object"))))
        `(lambda (,@(first arguments) ,@symbols)
           ,@(if (rest arguments)
                 `((let ,(loop for sym in symbols
                            for args in (rest arguments)
                            append (loop for arg in args
                                      collect `(,arg (and (find ,(string-downcase (string arg))
                                                                (jsown:keywords ,sym)
                                                                :test #'string=)
                                                          (jsown:val ,sym ,(string-downcase (string arg)))))))
                     ,@body))
                 body)))))
  
  (defmacro define-remote-procedure (name (&rest arguments) &body body)
    "defines a remote procedure with <name> as the name to be called and <arguments> as the assumed arguments.  if <name> is a symbol with only non- lower-case-p characters, then it is converted to lowercase."
    (flet ((translate-remote-procedure-name (name)
             (if (and (symbolp name)
                      (not (some #'lower-case-p (string name))))
                 (string-downcase (string name))
                 (string name))))
      `(register-remote-procedure
        ,(translate-remote-procedure-name name)
        ,(make-remote-procedure-lambda-function arguments body))))
#+end_src

** request identifiers (rids)
the rid is given by the javascript side.  it's a unique number to represent the current call to a function.  the rid is used to indicate running functions and to identify the source of results.  rids are stored in the session of the user.

when the rid is removed from the list of rids of that user, the thread which is executed for that rid should gracefully exit.  the thread needs to check if its rid still exists periodically.  results should only be pushed onto the stack of results, if the rid is still active.

#+begin_src lisp
  (defun rid-active-p (rid &optional (my-active-rids (screen-var 'rids)))
    "returns non-nil iff <rid> is active for the current user.  by use of the variable my-active-rids,
    the currently active rids can be overridden.  !only use when you know what you're doing!"
    (or (string= rid "")
        (find rid my-active-rids :test #'string=)))
  
  (defun start-rid (rid)
    "sets <rid> to be active"
    (with-local-screen-lock (!)
      (unless (rid-active-p rid)
        (! (push rid (screen-var 'rids))))))
  
  (defun remove-rid (rid)
    "removes the <rid> from the list of active rids"
    (with-local-screen-lock (!)
      (! (alexandria:removef (screen-var 'rids) rid :test #'string=))))
  
  (defun in-active-remote-procedure-p ()
    "returns non-nil if we are currently in a remote procedure with an active rid."
    (and *hydra-body* *hydra-head*
         *rid*
         (rid-active-p *rid*)
         (hydra-head-active-p *hydra-head*)
         (hydra-body-active-p *hydra-body*)))
  
  (defun activep ()
    "returns non-nil if we are currently in an active remote procedure.
    alias for in-active-remote-procedure-p."
    (in-active-remote-procedure-p))
#+end_src

** message boxes
the message box is a place in the session where requests can store messages for the client.  it has support for adding messages and for requesting the answers.  communication happens in jsown format.  we only care about messages for active rids are returned.

#+begin_src lisp
  (defun message (type body)
    "sends a message to the client"
    (with-local-screen-lock (!)
      (if (in-active-remote-procedure-p)
          (let ((message (jsown:new-js
                           ("type" type)
                           ("rid" *rid*)
                           ("body" body))))
            (! (push message (screen-var 'messages))))
          (warn "can't send messages if not in an active remote procedure"))))
  
  (defun fetch-and-clear-messages ()
    "fetches and clears the messages in the mailbox"
    (with-local-screen-lock (!)
      (let (messages my-active-rids)
        (!
         ;; fetch the list of messages
         (setf messages (screen-var 'messages))
         (setf (screen-var 'messages) nil)
         ;; correctly change the active rids
         (setf my-active-rids (screen-var 'rids))
         (let ((rids-to-end (screen-var 'rids-to-end)))
           (setf (screen-var 'rids)
                 (remove-if (lambda (rid)
                              (find rid rids-to-end :test #'string=))
                            (screen-var 'rids))))
         (setf (screen-var 'rids-to-end) nil))
        (delete-if-not (lambda (message)
                         (rid-active-p (jsown:val message "rid") my-active-rids))
                       (reverse messages)))))
#+end_src


* communication with the client
:PROPERTIES:
:noweb-ref: client-talk
:END:
requests and polling are initiated by the client.  all requests are sent to /intercom/talk.  the request may contain the following arguments:

- open :: array of json objects which describe the requests which the client makes in this request.
- close :: array of rids which describe the requests which the client wants to cancel.

all information about the client is stored in the client's session.  this means that all currently active requests (which aren't finished or haven't been canceled) are stored in the session and that all answers are stored in the session.  all responses are sent in json format.  the open and close requests are handled in separate functions.  the last function fetches all messages which should be sent to the client and converts them to the json format.

#+begin_src lisp
  (hunchentoot:define-easy-handler (talk :uri "/talk") ()
    (in-intercom-session
      (ensure-hydra)
      (setf (hunchentoot:content-type*) "application/json")
      (let ((open (hunchentoot:parameter "open"))
            (close (hunchentoot:parameter "close")))
        (when open
          (dolist (request (jsown:parse open))
            (perform-intercom-request request))) ;; [{rid,method,args}]
        (when close
          (dolist (rid (jsown:parse close))
            (perform-close-request rid)))) ;; rids
      (jsown:to-json (fetch-and-clear-messages))))
#+end_src

* communication channel timeout
:PROPERTIES:
:noweb-ref: timeouts
:END:
when clients get disconnected (either by closing the browser window or by a failed network connection), we have no way to send a request to the server to indicate this.  by logging the time when a user has made a request, we have an added check to ensure a thread is still running.

this system will only indicate to the threads that they may stop running.  it will not remove each of the threads, nor will it remove the store in the session and the head.  what it will do, is detach dead hydra-heads from the hydra-body.  it will also remove the session-validation objects which point to a dead hydra.

#+begin_src lisp
  (defun hash-keys (hash)
    "returns a list of all hash-keys in <hash>"
    (loop for k being the hash-keys of hash collect k))
  
  (defun gc-hydra-bodies ()
    "garbage collect the head hydras.  this removes the session-validation objects
    and removes the head heads."
    (bordeaux-threads:with-lock-held (*hydra-auth-lock*)
      (loop for k in (hash-keys *hydra-auth-store*)
         for validations =
           (remove-if-not (lambda (session-validation)
                            (let* ((hydra-body (session-validation-hydra-body
                                                session-validation))
                                   (activep (hydra-body-active-p hydra-body)))
                              (unless activep
                                ;; we need to decide what the throw away at this
                                ;;  time to ensure we don't forget to gc
                                (gc-hydra-body hydra-body))
                              activep))
                          (gethash k *hydra-auth-store*))
         if validations
         do 
           (setf (gethash k *hydra-auth-store*)
                 validations)
           (mapcar (compose #'gc-hydra-heads #'session-validation-hydra-body)
                   validations)
         else
         do
           (remhash k *hydra-auth-store*))))
  
  (defun gc-hydra-heads (hydra-body)
    "detaches the dead heads from <hydra-body>."
    ;;---! assumes hydra-body is locked by us
    (assert-hydra-body hydra-body)
    (let* ((new-heads (remove-if-not (lambda (head)
                                       (let ((activep (hydra-head-active-p head)))
                                         ;; we need to inline the garbage collection
                                         ;;  otherwise we may miss one somehow (though unlikely)
                                         (unless activep
                                           (gc-hydra-head head))
                                         activep))
                                     (hydra-body-heads hydra-body))))
      (setf (hydra-body-heads hydra-body)
            new-heads)))
  
  (bordeaux-threads:make-thread
   (let ((store *hydra-auth-store*)
         (lock *hydra-auth-lock*))
    (lambda ()
      (let ((*hydra-auth-store* store)
            (*hydra-auth-lock* lock))
        (loop do
             (sleep 1800) ;; we run every 30 minutes
             (gc-hydra-bodies)))))
   :name "hydras garbage collection thread")
#+end_src

* hydra-sessions
:PROPERTIES:
:noweb-ref: hydra
:END:
hydra-sessions allow users to connect to the system with multiple heads.  we call a session the hydra, the body of what you're doing, and the each visual frontend a head.  each head of the hydra describes the same user session, however their requests from the intercom side of life are seperated.  hydra-sessions don't use hunchentoot's session mechanism, it contains a mechanism that allows some slightly more fine-grained control over the death of hydra-heads and the hydra itself.

** storing sessions
in order to store sessions, we store the auth-keys and the authentications which belong to each key.  each authentication has a link to the hydra-body.  the hydra-body has a link to each of the hydra-heads which belong to it.  the correct one is found by using the hhid, which is sent with each intercom request.

#+begin_src lisp
  (defmacro with-hydra-auth-store-lock (&body body)
    "executes <body> in an environment in which *hydra-auth-store* is locked."
    `(bordeaux-threads:with-lock-held (*hydra-auth-lock*)
       ,@body))
  
  (defun store-hydra-validation (session-validation)
    "stores the hydra session-validation so it can be found back."
    (assert-hydra-session-validation session-validation)
    (assert-hydra-body (session-validation-hydra-body session-validation))
    (with-hydra-auth-store-lock
      (push session-validation
            (gethash (session-validation-hydra-id session-validation)
                     *hydra-auth-store*))))
  
  (defun retrieve-hydra-validations (hydra-id)
    "returns all hydra session-varlidation instance which belong to the given hydra-id"
    (assert-nonempty-string hydra-id)
    (with-hydra-auth-store-lock
      (gethash hydra-id
               *hydra-auth-store*)))
  
  (defun remove-hydra-validation (session-validation)
    "removes the session-validation <session-validation> from the known validations."
    (assert-hydra-session-validation session-validation)
    (with-hydra-auth-store-lock
      ;;---! do something smart with a counter in the hydra-body here so we know the hydra-body should be terminated too
      (remhash (session-validation-hydra-id session-validation)
               *hydra-auth-store*)))
#+end_src

** setting hydra up for a request
whenever a request enters, we need to ensure the hydra is setup.  it must either be found, or built.  this section handles that portion of the hydra.

#+begin_src lisp
  (defun ensure-hydra ()
    "ensures the hydra is set up.  this means that:
    - after this function execution:
      - *hydra-head* is bound to the hydra's head
      - *hydra-body* is bound to the hydra's body
      - *hydra-auth-store* contains an authentication for continued storage
    - after this request:
      - the user has a \"hydra\" cookie which links to this session."
    (unless (discover-hydra)
      (let ((hydra-body (build-active-hydra-body)))
        (ensure-hydra-head hydra-body)
        (build-active-authentication hydra-body))))
  
  (defun build-active-hydra-body ()
    "builds a new hydra-body and sets it as the current hydra-body."
    (setf *hydra-body* (make-hydra-body)))
  
  (defun build-active-authentication (hydra-body)
    "builds a new authentication, which identifies hydra-body, and stores it
    in the necessary structures."
    (let ((id (s+ (generate-id))))
      (store-hydra-validation (make-session-validation hydra-body id))
      ;;---! this cookie is never updated.  it should be updated every so often so we can
      ;;     keep the session alive
      (hunchentoot:set-cookie "hydra"
                              :value id
                              :http-only t
                              :expires (+ (get-universal-time)
                                          (* 60 60 24 30)))))
  
  (defun discover-hydra ()
    "discover-hydra returns non-nil iff we had a session-cookie through which we could
    find a hydra session-validation which is valid for our current session.
    this function sets up all special variables for the hydra to be happy.  it also
    touches the hydra-body and the relevant hydra-head so we're active."
    (when (discover-hydra-body)
      (ensure-hydra-head *hydra-body*)))
  
  (defun discover-hydra-body ()
    "returns non-nil iff we had a session-cookie through which we could
    find a hydra session-validation which is valid for our current session.
    this function sets up all special variables for the hydra-body,
    but leaves the hydra-head for another solution to figure out."
    (esc (^)
      (setf *hydra-body*
            (session-validation-hydra-body
             (let ((cookie (^ (hunchentoot:cookie-in "hydra"))))
               (^ (find-if (rcurry #'valid-session-p cookie)
                           (retrieve-hydra-validations cookie))))))
      (touch *hydra-body*)
      *hydra-body*))
  
  (defun ensure-hydra-head (hydra-body)
    "ensures the hydra-head exists and is set in the variable *hydra-head*.
    assumes *hydra-body* is set.  returns the current hydra-head."
    (multiple-value-bind (hhid need-to-send-hhid-p)
        (ensure-hhid)
      (let ((hydra-head (find hhid (hydra-body-heads hydra-body)
                              :test #'string= :key #'hydra-head-id)))
        (if hydra-head
            (progn
              (touch hydra-head)
              (setf *hydra-head* hydra-head))
            (let ((new-head (make-hydra-head :id hhid)))
              (setf *hydra-head* new-head)
              (push new-head (hydra-body-heads hydra-body)))))
      (when need-to-send-hhid-p
        (send-current-hhid)))
    *hydra-head*)
  
  (defun ensure-hhid ()
    "returns the hhid if one was given as a get-variable, or creates a new hhid.
    does *not* put the hhid on the message stack.
    returns (values hhid newp).  if newp is t, a message should be sent to the
    client (see (send-current-hhid)) so the client knows the hhid."
    (let (resend-p)
      (values
       (or (let ((special *hydra-head-id*))
             special)
           (let ((get (hunchentoot:get-parameter "hhid")))
             (setf *hydra-head-id* get)
             get)
           (let ((new (s+ (generate-id))))
             (setf *hydra-head-id* new)
             (setf resend-p t)
             new))
       resend-p)))
  
  (defun send-current-hhid ()
    "sends the current hhid to the client by using the correct intercom message.
    requires that *hydra-head* and *hydra-head-id* are set correctly."
    (assert-hydra-head *hydra-head*)
    (assert-nonempty-string *hydra-head-id*)
    (let ((*rid* ""))
      (message "hhid" *hydra-head-id*)))
#+end_src


** hydra body
a hydra body is identified by a cookie value.  we base our cookies on regular http-only cookie-values and store the session-cookie in the browser.

*** hydra body (session) representation
the hydra body is represented as a struct which may contain some information.  hydra-body in itself knows about the heads that are attached to it (NOTE: for fast finding of head).  it doesn't link to the validators which may validate the hydra-body.

#+begin_src lisp
  (defstruct hydra-body
    (data (make-key-value-store))
    (atime (get-universal-time))
    (heads nil)
    (gc-callbacks nil)
    (garbage-collected-body-p nil))
  
  (defmethod touch ((hydra hydra-body))
    (setf (hydra-body-atime hydra)
          (get-universal-time)))
  
  (defun gc-hydra-body (hydra-body)
    "garbage-collects a hydra-body"
    (dolist (head (hydra-body-heads hydra-body))
      (gc-hydra-head head))
    (dolist (callback (hydra-body-gc-callbacks hydra-body))
      (funcall callback))
    (setf (hydra-body-garbage-collected-body-p hydra-body) t))
  
  (defun session-var (key &optional (session *hydra-body*))
    "returns the value of <key> which belongs to <session>, or nil if it didn't exist.
    the second value is non-nil iff <key> was found in <session>."
    (kv-store-read key (hydra-body-data session)))
  
  (defun (setf session-var) (value key &optional (session *hydra-body*))
    "sets the value of ,key> which belongs to <session> to <value>."
    (setf (kv-store-read key (hydra-body-data session)) value))
  
  (defun attach-head (hydra-body hydra-head)
    "attaches <hydra-head> to <hydra-body>"
    (assert-hydra-body hydra-body)
    (assert-hydra-head hydra-head)
    (push hydra-head (hydra-body-heads hydra-body)))
  
  (defun hydra-body-active-p (hydra)
    "returns non-nil iff the <hydra> hasn't been touched for too long of a time."
    (and (not (hydra-body-garbage-collected-body-p hydra))
         (> (+ (hydra-body-atime hydra) *hydra-body-timeout*)
            (get-universal-time))))
#+end_src



** hydra head
the hydra head represents a single visualisation of the hydra body.  each head is identified by a number.  the number, in combination with the body can be used to send messages back to the head.

*** hydra head (screen) representation
the hydra-head is very similar to the hydra-body.  the main difference is that the head knows about its body.

#+begin_src lisp
  (defstruct hydra-head
    (id nil)
    (data (make-key-value-store))
    (atime (get-universal-time))
    (gc-callbacks nil)
    (garbage-collected-body-p nil))
  
  (defmethod touch ((hydra hydra-head))
    (setf (hydra-head-atime hydra)
          (get-universal-time)))
  
  (defun gc-hydra-head (hydra-head)
    "garbage-collects a hydra-head"
    (dolist (callback (hydra-head-gc-callbacks hydra-head))
      (funcall callback))
    (setf (hydra-head-garbage-collected-body-p hydra-head) t))
  
  (defun screen-var (key &optional (screen *hydra-head*))
    "returns the value of <key> which belongs to <screen>, or nil if it didn't exist.
      the second value is non-nil iff <key> was found in <screen>."
    (kv-store-read key (hydra-head-data screen)))
  
  (defun (setf screen-var) (value key &optional (screen *hydra-head*))
    "sets the value of ,key> which belongs to <screen> to <value>."
    (setf (kv-store-read key (hydra-head-data screen)) value))
  
  (defun hydra-head-active-p (hydra)
    "returns non-nil iff the <hydra> hasn't been touched for too long of a time."
    (and (not (hydra-head-garbage-collected-body-p hydra))
         (> (+ (hydra-head-atime hydra) *hydra-head-timeout*)
            (get-universal-time))))
#+end_src

** session validation
in order to validate that a session is still 'live', we check the following parameters:
- hydra cookie value
- host
- user-agent

#+begin_src lisp
  (defstruct (session-validation (:constructor mk-session-validation))
    (hydra-id "" :type string)
    (host "" :type string)
    (user-agent "" :type string)
    (hydra-body nil :type (or hydra-body null)))
  
  (defun valid-session-p (session-validation cookie-identifier)
    "validates the session-validation for the current request"
    (and (string= cookie-identifier (session-validation-hydra-id session-validation))
         (string= (hunchentoot:host) (session-validation-host session-validation))
         (string= (hunchentoot:user-agent) (session-validation-user-agent session-validation))))
  
  (defun make-session-validation (hydra-body cookie-identifier)
    "constructs a new session-validation object for the current session."
    (mk-session-validation :hydra-id cookie-identifier
                           :hydra-body hydra-body
                           :host (hunchentoot:host)
                           :user-agent (hunchentoot:user-agent)))
#+end_src

FUTURE WORK: additionally a quality measure can be used for added certainty.  this quality measure should weigh the following values and should compare them to the last request in order to see if the given request is presumed to be valid:
- real-remote-addr
- server-protocol
- remote-port
- remote-addr

* handling requests
:PROPERTIES:
:noweb-ref: rpc
:END:
the client may send requests and may cancel requests.  the requests which are accepted must be defined in the software system.  we allow the application pogrammer to register requests and how they should be handled.  when handling a request, the programmer can send answers to the client.  when the request is finished, it is automatically closed.

** performing intercom method call requests
when an intercom request is performed, we receive the request in jso(w)n format.  the necessary information is parsed from the request and the registered request is called.

#+begin_src lisp
  (defun perform-intercom-request (jsown-request)
    "performs an intercom request as described by <jsown-request>."
    (apply #'call-remote-procedure
           (jsown:val jsown-request "rid")
           (jsown:val jsown-request "name")
           (jsown:val jsown-request "args")))
#+end_src

** performing intercom close requests
when a close request is handled, we must remove the rid.  the thread which is executing the request must manually find out whether or not it is still wanted and stop itself when it is safe to do so.

#+begin_src lisp
  (defun perform-close-request (rid)
    "closes the request for the rid."
    (remove-rid rid))
#+end_src


* support code
:PROPERTIES:
:noweb-ref: support
:END:
some handy snippets of code which make some code easier to write.

#+begin_src lisp
  (defun s+ (&rest args)
    "pretty-prints and concatenates the resulting strings of each arg in <args>."
    (format nil "~{~A~}" args))
  
  (defmacro with-doublequotes ((&rest variables) &body body)
    "makes sure each variable in variables is bound to itself, essentially allowing you to write ,, in a double backtick to get that symbol.  handy for gensym."
    `(let ,(loop for var in variables
              collect `(,var ',var))
       ,@body))
  
  (defmacro esc ((macro-symbol &key (test ''null) (return nil)) &body body)
    (with-gensyms (form-var block-var val test-var return-var)
      `(block ,block-var
         (let ((,test-var ,test)
               (,return-var ,return))
           (macrolet ((,macro-symbol (,form-var)
                        (with-doublequotes (,block-var ,val ,test-var ,return-var)
                          `(let ((,,val ,,form-var))
                             (if (funcall ,,test-var ,,val)
                                 (return-from ,,block-var ,,return-var)
                                 ,,val)))))
             ,@body)))))
  
  (defun generate-id ()
    "we generate an id by taking the universal time and augmenting it by some random number"
    (let ((random-binary-digits 35)
          (universal-time-binary-digits 25))
      ;; let's only care about the last 20 digits of universal time, this gives us roughly one year to cycle
      (+ (* (mod (get-universal-time) (expt 2 universal-time-binary-digits))
            (expt 2 random-binary-digits))
         (random (expt 2 random-binary-digits)))))
#+end_src

** assertions
various assertions are used, they're tedious to write manually each time.

#+begin_src lisp
  (defmacro assert-nonempty-string (place)
    "asserts that <place> contains a non-empty string."
    `(assert (and (stringp ,place)
                  (> (length ,place) 0))
             (,place)
             "~A must contain a nonempty string.  it contains ~A" ',place ,place))
  
  (defmacro assert-eql-compatible (place)
    "asserts that place is an eql-compatible place.
    this means it must be one of:
    1. a symbol
    2. a character
    3. a number"
    `(assert (or (symbolp ,place)
                 (numberp ,place)
                 (characterp ,place))
             (,place)
             "~A must contain an object which may be eql-compatible when copied.  it contains ~A." ',place ,place))
  
  (defmacro assert-hydra-head (place)
    "asserts that <place> contains a hydra-head"
    `(assert (hydra-head-p ,place)
             (,place)
             "~A must contain an object of type hydra-head.  it contains ~A." ',place ,place))
  
  (defmacro assert-hydra-body (place)
    "asserts that <place> contains a hydra-body"
    `(assert (hydra-body-p ,place)
             (,place)
             "~A must contain an object of type hydra-body.  it contains ~A." ',place ,place))
  
  (defmacro assert-hydra-session-validation (place)
    "asserts that <place> contains a hydra-session"
    `(assert (session-validation-p ,place)
             (,place)
             "~A must contain an object of type session-validation.  it contains ~A." ',place ,place))
#+end_src

** key-value storage
both a hydra-body as a hydra-head need to have some form of key-value store.  the key-value store is represented with this struct.

#+begin_src lisp
  (defstruct key-value-store
    (lock (bordeaux-threads:make-recursive-lock "key-value-lock"))
    (hash (make-hash-table)))
  
  (defmacro with-key-value-store-lock (store &body body)
    "executes body in an environment in which <store> is locked."
    `(bordeaux-threads:with-recursive-lock-held ((key-value-store-lock ,store))
       ,@body))
  
  (defun kv-store-read (key store)
    "reads the key from store"
    (declare (type key-value-store store))
    (assert-eql-compatible key)
    (with-key-value-store-lock store
      (gethash key (key-value-store-hash store))))
  
  (defun (setf kv-store-read) (value key store)
    "sets <key> in <store> to <value>"
    (declare (type key-value-store store))
    (assert-eql-compatible key)
    (with-key-value-store-lock store
      (setf (gethash key (key-value-store-hash store))
            value)))
#+end_src



* bolting together the tangled file
in this section all the code fragments are joined together for the lisp source file(s).

#+begin_src lisp :tangle intercom.lisp
  (in-package :intercom)
  
  <<generic-functions>>
  
  <<support>>
  
  <<data-structures>>
  
  <<hydra>>
  
  <<client-talk>>
  
  <<timeouts>>
  
  <<rpc>>
#+end_src


* some examples

#+begin_src lisp :tangle intercom-examples.lisp
  (defpackage :intercom-examples
    (:use :cl :intercom))
  
  (in-package :intercom-examples)
  
  (define-remote-procedure test (count base diff)
    (loop repeat count
       for time = (+ base (random diff))
       do
         (sleep time)
         (message "bark" time))
    (message "cemetary" "senna died! :`("))
  
  (define-remote-procedure echo (&key string count interval)
    (loop repeat count
       do (sleep (/ interval 1000)) ; we don't have a really good idea how good the sleep works
         (message "value" string))
    (message "ready" :true))
  
  (define-remote-procedure eval (string)
    (message "ready" (eval (read string))))
  
  (defun rand-between (a b)
    "returns a number between min and max"
    (+ (min a b) (random (abs (- a b)))))
  (define-remote-procedure timeout (count min-ms max-ms end-key)
    (let ((start-time (get-internal-real-time)))
      (loop for nr from 0 below count
         for sleepytime = (rand-between (/ min-ms 1000) (/ max-ms 1000))
         do (message "current-time" (jsown:new-js ("count" nr)
                                                  ("timeout" (round (* sleepytime 1000)))
                                                  ("total-time" (round (* (/ (- (get-internal-real-time) start-time)
                                                                             internal-time-units-per-second)
                                                                          1000))))))
      (message end-key "ok")))
#+end_src

we add an asd files to make the loading of the examples a tad easier.

#+begin_src lisp :tangle intercom-examples.asd
  (asdf:defsystem :intercom-examples
    :name "Intercom"
    :author "Aad Versteden <madnificent@gmail.com>"
    :version "0.0.1"
    :maintainer "Aad Versteden <madnificent@gmail.com>"
    :licence "MIT"
    :description "Some example remote procedures for intercom"
    :depends-on (intercom jsown)
    :serial t
    :components ((:file "intercom-examples")))
#+end_src
