#+PROPERTY: tangle no
#+PROPERTY: cache no
#+PROPERTY: session yes
#+PROPERTY: results silent
#+PROPERTY: no-expand yes
#+PROPERTY: noweb yes
#+PROPERTY: exports code
#+PROPERTY: padline yes
Lisp Intercom

this document describes the intercom system from the lisp side.  this contains the description of how to send and receive documents from the client and how to handle them.

* prerequisites
intercom assumes the existence of hunchentoot and of jsown for communication with the clients.  it publishes two paths to handle the communication.

#+begin_src lisp :tangle intercom.asd
  (asdf:defsystem :intercom
    :name "Intercom"
    :author "Aad Versteden <aad@knowified.com>"
    :author "Karel Kremer <karel@knowified.com>"
    :version "0.0.1"
    :maintainer "Aad Versteden <aad@knowified.com>"
    :licence "MIT"
    :description "Intercom allows bidirectional message passing between javascript and lisp."
    :depends-on (jsown hunchentoot bordeaux-threads split-sequence alexandria)
    :serial t
    :components ((:file "packages")
                 (:file "intercom")))
#+end_src

* package specification
intercom is simple and consists of one package which exports everything.  we didn't opt for a special separate package for the implementation due to the limited amount of exported constructs.

#+begin_src lisp :tangle packages.lisp
  (defpackage :intercom
    (:use :cl :jsown :alexandria)
    (:export :define-remote-procedure
             :message :activep
             :*remote-procedure-context*
             :*watchdog-timeout*))
#+end_src

* generic functions
:PROPERTIES:
:noweb-ref: generic-functions
:END:
generic functions are best defined at the top of the lisp file.  we define the generic functions here, but implement them in the relevant sections.

#+begin_src lisp
  (defgeneric touch (object)
    (:documentation "touches an object, updating the modification time."))
#+end_src

* data structures
:PROPERTIES:
:noweb-ref: data-structures
:END:

most of the information about the threads is stored in the user's session.  the datastructures and the operations which can occur on them are described in this section.

** parameters
we define the parameters separately, this makes it clear what all the relevant parameters are.

#+begin_src lisp
  (defparameter *remote-procedures* (make-hash-table :test 'equal :synchronized t)
    "contains all intercom remote procedures, the keywords being the matched string and the values being the corresponding function.")
  
  (defparameter *rid* nil
    "variable which contains the request id in functions which represent the execution of a remote procedure.")
  
  (defparameter *store* nil
    "contains a key-value store for the variables which *should* be in the session")
  
  (defparameter *watchdog-timeout* 600
    "if the javascript intercom side doesn't talk to us for more than *watchdog-timeout* seconds, we close down the active connections.")
  
  (defparameter *hydra-body-id* nil
    "if we're currently in a hydra session, this contains the secret in the session.")
  
  (defparameter *hydra-body* nil
    "contains the hydra-body once we have a hydra-body in the current request")
  
  (defparameter *hydra-body-timeout* 86400
    "the time we have before we assume the session has ended.")
  
  (defparameter *hydra-head-id* nil
    "represents the screen identifier of the current request")
  
  (defparameter *hydra-head* nil
    "contains the hydra-head once we have one in the current request")
  
  (defparameter *hydra-head-timeout* 600
    "the time we have before we assume the head is detached.")
#+end_src

** user session
the session of the user will be contacted on various occasions, in multiple threads.  therefore, we create a function which creates the session and -if necessary- populates it with a lock which should be held when modifying the variables in the session.  some sugar is added to manage the session locks in the macro with-session-lock.

#+begin_src lisp
  (defmacro with-session-lock ((protection-symbol) &body body)
    "executes <body> in a piece of code in which the session is locked"
    `(progn
       (assert-session)
       (macrolet ((,protection-symbol (&body body)
                    `(bordeaux-threads:with-recursive-lock-held ((gethash 'intercom-session-lock *store*))
                       ,@body)))
         ,@body)))
  
  (defmacro in-intercom-session (&body body)
    "executes a hunchentoot request in an environment in which *store* is bound to the current store."
    (let ((store-exists-p (gensym "store-exists-p")))
      `(progn (hunchentoot:start-session)
              (let ((,store-exists-p (hunchentoot:session-value 'store hunchentoot:*session*))
                    *store*)
                (unless ,store-exists-p
                  (setf (hunchentoot:session-value 'store hunchentoot:*session*)
                        (make-hash-table :synchronized t)))
                (setf *store* (hunchentoot:session-value 'store hunchentoot:*session*))
                (unless ,store-exists-p
                  (setf (gethash 'intercom-session-lock *store*)
                        (bordeaux-threads:make-lock "intercom session lock")))
                ,@body))))
  
  (defun assert-session ()
    "asserts that we're currently running in an environment which is sane for intercom requests/executions"
    (assert *store*)
    (assert (gethash 'intercom-session-lock *store*)))
  
  (defun intercom-var (variable)
    "returns <variable> from the session in *store*"
    (with-session-lock (!)
      (! (gethash variable *store*))))
  
  (defun (setf intercom-var) (value variable)
    (with-session-lock (!)
      (! (setf (gethash variable *store*) value))))
#+end_src

** remote procedures
a remote procedure connects a string to a function to be called when a request is received to call the function with that name.  call-remote-procedure abstracts between the definition with strings or with symbols.

#+begin_src lisp
  (defun register-remote-procedure (name function)
    "registers the remote procedure for <name> to be <function>."
    (when (gethash name *remote-procedures*)
      (warn "overwriting remote procedure for ~A" name))
    (setf (gethash name *remote-procedures*) function))
  
  (defun get-remote-procedure (name)
    "returns the remote procedure for <name> or nil if the procedure doesn't exist."
    (gethash name *remote-procedures*))
  
  (defparameter *remote-procedure-context* nil
    "should contain an alist in which the keywords are special variables and the values
     are evaluated (in the creating thread) each time a remote procedure is built.
     this allows you to pass special variables.")
  
  (defun thread-initial-bindings ()
    "calculates the initial bindings for the current thread.  this consists of whatever
     is available in bordeaux-threads:*initial-bindings*, but with what
     *remote-procedure* contains in front of it (in which the values are evaluated)."
    (concatenate 'list
                 (loop for (k . v) in *remote-procedure-context*
                    collect (cons k (eval v)))
                 bordeaux-threads:*default-special-bindings*))
  
  (defun call-remote-procedure (rid name &rest args)
    "calls the remote prodecure with name <name> and <args> as the arguments with <rid> as reference.  assumes the special variable *store* exists"
    (assert (get-remote-procedure name))
    (bordeaux-threads:make-thread
     (let ((store *store*)
           (session hunchentoot:*session*))
       (lambda ()
         (let ((*store* store)
               (*rid* rid)
               (hunchentoot:*session* session))
           (start-rid *rid*)
           (unwind-protect
                (apply (get-remote-procedure name) args)
             (with-session-lock (!)
               (push rid (intercom-var 'rids-to-end)))))))
     :initial-bindings (thread-initial-bindings)
     :name name))
#+end_src

some syntactic sugar to define remote procedures is obviously welcome.  this is handled in the following piece of code.

#+begin_src lisp
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun make-remote-procedure-lambda-function (arguments body)
      "builds the s-expression representation for the lambda function which can be called for the definition of a remote procedure.  this handles the creation of the &key arguments."
      (let* ((arguments (split-sequence:split-sequence '&key arguments))
             (symbols (loop repeat (1- (length arguments)) collect (gensym "jsown-object"))))
        `(lambda (,@(first arguments) ,@symbols)
           ,@(if (rest arguments)
                 `((let ,(loop for sym in symbols
                            for args in (rest arguments)
                            append (loop for arg in args
                                      collect `(,arg (and (find ,(string-downcase (string arg))
                                                                (jsown:keywords ,sym)
                                                                :test #'string=)
                                                          (jsown:val ,sym ,(string-downcase (string arg)))))))
                     ,@body))
                 body)))))
  
  (defmacro define-remote-procedure (name (&rest arguments) &body body)
    "defines a remote procedure with <name> as the name to be called and <arguments> as the assumed arguments.  if <name> is a symbol with only non- lower-case-p characters, then it is converted to lowercase."
    (flet ((translate-remote-procedure-name (name)
             (if (and (symbolp name)
                      (not (some #'lower-case-p (string name))))
                 (string-downcase (string name))
                 (string name))))
      `(register-remote-procedure
        ,(translate-remote-procedure-name name)
        ,(make-remote-procedure-lambda-function arguments body))))
#+end_src

** request identifiers (rids)
the rid is given by the javascript side.  it's a unique number to represent the current call to a function.  the rid is used to indicate running functions and to identify the source of results.  rids are stored in the session of the user.

when the rid is removed from the list of rids of that user, the thread which is executed for that rid should gracefully exit.  the thread needs to check if its rid still exists periodically.  results should only be pushed onto the stack of results, if the rid is still active.

#+begin_src lisp
  (defun rid-active-p (rid &optional (my-active-rids (intercom-var 'rids)))
    "returns non-nil iff <rid> is active for the current user.  by use of the variable my-active-rids,
    the currently active rids can be overridden.  !only use when you know what you're doing!"
    (or (string= rid "")
        (find rid my-active-rids :test #'string=)))
  
  (defun start-rid (rid)
    "sets <rid> to be active"
    (with-session-lock (!)
      (unless (rid-active-p rid)
        (! (push rid (intercom-var 'rids))))))
  
  (defun remove-rid (rid)
    "removes the <rid> from the list of active rids"
    (with-session-lock (!)
      (! (alexandria:removef (intercom-var 'rids) rid :test #'string=))))
  
  (defun in-active-remote-procedure-p ()
    "returns non-nil if we are currently in a remote procedure with an active rid."
    (and *store* *rid*
         (rid-active-p *rid*)
         (channel-activep)))
  
  (defun activep ()
    "returns non-nil if we are currently in an active remote procedure.
    alias for in-active-remote-procedure-p."
    (in-active-remote-procedure-p))
#+end_src

** message boxes
the message box is a place in the session where requests can store messages for the client.  it has support for adding messages and for requesting the answers.  communication happens in jsown format.  we only care about messages for active rids are returned.

#+begin_src lisp
  (defun message (type body)
    "sends a message to the client"
    (with-session-lock (!)
      (if (in-active-remote-procedure-p)
          (let ((message (jsown:new-js
                           ("type" type)
                           ("rid" *rid*)
                           ("body" body))))
            (! (push message (intercom-var 'messages))))
          (warn "can't send messages if not in an active remote procedure"))))
  
  (defun fetch-and-clear-messages ()
    "fetches and clears the messages in the mailbox"
    (with-session-lock (!)
      (let (messages my-active-rids)
        (!
         ;; fetch the list of messages
         (setf messages (intercom-var 'messages))
         (setf (intercom-var 'messages) nil)
         ;; correctly change the active rids
         (setf my-active-rids (intercom-var 'rids))
         (let ((rids-to-end (intercom-var 'rids-to-end)))
           (setf (intercom-var 'rids)
                 (remove-if (lambda (rid)
                              (find rid rids-to-end :test #'string=))
                            (intercom-var 'rids))))
         (setf (intercom-var 'rids-to-end) nil))
        (delete-if-not (lambda (message)
                         (rid-active-p (jsown:val message "rid") my-active-rids))
                       (reverse messages)))))
#+end_src


* communication with the client
:PROPERTIES:
:noweb-ref: client-talk
:END:
requests and polling are initiated by the client.  all requests are sent to /intercom/talk.  the request may contain the following arguments:

- open :: array of json objects which describe the requests which the client makes in this request.
- close :: array of rids which describe the requests which the client wants to cancel.

all information about the client is stored in the client's session.  this means that all currently active requests (which aren't finished or haven't been canceled) are stored in the session and that all answers are stored in the session.  all responses are sent in json format.  the open and close requests are handled in separate functions.  the last function fetches all messages which should be sent to the client and converts them to the json format.

#+begin_src lisp
  (hunchentoot:define-easy-handler (talk :uri "/talk") ()
    (in-intercom-session
      (watchdog)
      (ensure-hydra-head)
      (setf (hunchentoot:content-type*) "application/json")
      (let ((open (hunchentoot:parameter "open"))
            (close (hunchentoot:parameter "close")))
        (when open
          (dolist (request (jsown:parse open))
            (perform-intercom-request request))) ;; [{rid,method,args}]
        (when close
          (dolist (rid (jsown:parse close))
            (perform-close-request rid)))) ;; rids
      (jsown:to-json (fetch-and-clear-messages))))
#+end_src

* communication channel timeout
:PROPERTIES:
:noweb-ref: timeouts
:END:
when clients get disconnected (either by closing the browser window or by a failed network connection), we have no way to send a request to the server to indicate this.  by logging the time when a user has made a request, we have an added check to ensure a thread is still running.

this system will only indicate to the threads that they may stop running.  it will not remove each of the threads, nor will it remove the store in the session.

#+begin_src lisp
  (defun watchdog ()
    "indicates the client has phoned home"
    (setf (intercom-var 'watchdog)
          (get-universal-time)))
  
  (defun channel-activep ()
    "returns non-nil iff the last message we received from the client isn't too long ago"
    (>= (+ (intercom-var 'watchdog) *watchdog-timeout*)
        (get-universal-time)))
#+end_src

* hydra-sessions
:PROPERTIES:
:noweb-ref: hydra
:END:
hydra-sessions allow users to connect to the system with multiple heads.  we call a session the hydra, the body of what you're doing, and the each visual frontend a head.  each head of the hydra describes the same user session, however their requests from the intercom side of life are seperated.  hydra-sessions don't use hunchentoot's session mechanism, it contains a mechanism that allows some slightly more fine-grained control over the death of hydra-heads and the hydra itself.

** hydra body
a hydra body is identified by a cookie value.  we base our cookies on regular http-only cookie-values and store the session-cookie in the browser.

#+begin_src lisp
  (defun generate-id ()
    "we generate an id by taking the universal time and augmenting it by some random number"
    (let ((random-binary-digits 35)
          (universal-time-binary-digits 25))
      ;; let's only care about the last 20 digits of universal time, this gives us roughly one year to cycle
      (+ (* (mod (get-universal-time) (expt 2 universal-time-binary-digits))
            (expt 2 random-binary-digits))
         (random (expt 2 random-binary-digits)))))
  
  (defun ensure-hydra-body (&optional refreshp)
    "creates a new session and session cookie, unless one was given to us that still exists"
    ;;---! this should check that that the session cookie really is a session and set it up
    (let ((hydra-cookie (hunchentoot:cookie-in "hydra")))
      (setf *hydra-body-id*
            (or hydra-cookie (s+ (generate-id))))
      ;;---! and setup the hydra structures in memory 
      (unless hydra-cookie
        nil ;;---! ensure hydra-session is setup in memory
        )
      (when (or refreshp (not hydra-cookie))
        (hunchentoot:set-cookie "hydra"
                                :value *hydra-body-id*
                                :http-only t
                                :expires (+ (get-universal-time)
                                            (* 60 60 24 30))))))
#+end_src

** hydra head
the hydra head represents a single visualisation of the hydra body.  each head is identified by a number.  the number, in combination with the body can be used to send messages back to the head.

#+begin_src lisp
  (defun ensure-hydra-head ()
    "ensures *hydra-head-id* is available.  also ensures the *hydra-body-id* is set.
    refreshes *hydra-body-id* when no hhid was found in the current request."
    (let* ((hhid (hunchentoot:get-parameter "hhid"))
           (*hydra-head-id* (s+ (or hhid (generate-id)))))
      (ensure-hydra-body hhid)
      ;;---! setup the datastructures for both the head and the body!
      (unless hhid
        (let ((*rid* ""))
          (message "hhid" *hydra-head-id*)))))
#+end_src

** session validation
in order to validate that a session is still 'live', we check the following parameters:
- hydra cookie value
- host
- user-agent

#+begin_src lisp
  (defstruct (session-validation (:constructor mk-session-validation))
    (hydra-id "" :type string)
    (host "" :type string)
    (user-agent "" :type string))
  
  (defun valid-session-p (session-validation)
    "validates the session-validation for the current request"
    (and (string= *hydra-body-id* (session-validation-hydra-id session-validation))
         (string= (hunchentoot:host) (session-validation-host session-validation))
         (string= (hunchentoot:user-agent) (session-validation-user-agent session-validation))))
  
  (defun make-session-validation (&optional (hydra-id *hydra-body-id*))
    "constructs a new session-validation object for the current session."
    (mk-session-validation :hydra-id hydra-id
                           :host (hunchentoot:host)
                           :user-agent (hunchentoot:user-agent)))
#+end_src

FUTURE WORK: additionally a quality measure can be used for added certainty.  this quality measure should weigh the following values and should compare them to the last request in order to see if the given request is presumed to be valid:
- real-remote-addr
- server-protocol
- remote-port
- remote-addr

** key-value storage
both a hydra-body as a hydra-head need to have some form of key-value store.  the key-value store is represented with this struct.

#+begin_src lisp
  (defstruct key-value-store
    (lock (bordeaux-threads:make-recursive-lock "key-value-lock"))
    (hash (make-hash-table)))
  
  (defmacro with-key-value-store-lock (store &body body)
    "executes body in an environment in which <store> is locked."
    `(bordeaux-threads:with-recursive-lock-held ((key-value-store-lock ,store))
       ,@body))
  
  (defun kv-store-read (key store)
    "reads the key from store"
    (declare (type key-value-store store))
    (assert-eql-compatible key)
    (with-key-value-store-lock store
      (gethash key (key-value-store-hash store))))
  
  (defun (setf kv-store-read) (value key store)
    "sets <key> in <store> to <value>"
    (declare (type key-value-store store))
    (assert-eql-compatible key)
    (with-key-value-store-lock store
      (setf (gethash key (key-value-store-hash store))
            value)))
#+end_src

** hydra body (session) representation
the hydra body is represented as a struct which may contain some information.  hydra-body in itself knows about the heads that are attached to it (NOTE: for fast finding of head).  it doesn't link to the validators which may validate the hydra-body.

#+begin_src lisp
  (defstruct hydra-body
    (data (make-key-value-store))
    (atime (get-universal-time))
    (heads nil))
  
  (defmethod touch ((hydra hydra-body))
    (setf (hydra-body-atime hydra)
          (get-universal-time)))
  
  (defun session-key (key &optional (session *hydra-body*))
    "returns the value of <key> which belongs to <session>, or nil if it didn't exist.
    the second value is non-nil iff <key> was found in <session>."
    (kv-store-read key (hydra-body-data session)))
  
  (defun (setf session-key) (value key &optional (session *hydra-body*))
    "sets the value of ,key> which belongs to <session> to <value>."
    (setf (kv-store-read key (hydra-body-data session)) value))
  
  (defmacro with-session-db-lock ((&optional (session *hydra-body*)) &body body)
    "executes <body> with a lock on the datastore of hydra-body.
    this should be used when the new value is based on previous values in the session."
    `(with-key-value-store-lock (hydra-body-data ,session)
       ,@body))
  
  (defun attach-head (hydra-body hydra-head)
    "attaches <hydra-head> to <hydra-body>"
    (assert-hydra-body hydra-body)
    (assert-hydra-head hydra-head)
    (push hydra-head (hydra-body-heads hydra-body)))
  
  (defun hydra-body-stale-p (hydra)
    "returns non-nil iff the <hydra> hasn't been touched for too long of a time."
    (< (+ (hydra-body-atime hydra) *hydra-body-timeout*)
       (get-universal-time)))
#+end_src

** hydra head (screen) representation
the hydra-head is very similar to the hydra-body.  the main difference is that the head knows about its body.

#+begin_src lisp
  (defstruct hydra-head
    (id nil)
    (data (make-key-value-store))
    (atime (get-universal-time)))
  
  (defmethod touch ((hydra hydra-head))
    (setf (hydra-head-atime hydra)
          (get-universal-time)))
  
  (defun screen-key (key &optional (screen *hydra-head*))
    "returns the value of <key> which belongs to <screen>, or nil if it didn't exist.
      the second value is non-nil iff <key> was found in <screen>."
    (kv-store-read key (hydra-head-data screen)))
  
  (defun (setf screen-key) (value key &optional (screen *hydra-head*))
    "sets the value of ,key> which belongs to <screen> to <value>."
    (setf (kv-store-read key (hydra-head-data screen)) value))
  
  (defmacro with-screen-db-lock ((&optional (session *hydra-head*)) &body body)
    "executes <body> with a lock on the datastore of hydra-head.
      this should be used when the new value is based on previous values in the session."
    `(with-key-value-store-lock (hydra-head-data ,session)
       ,@body))
  
  (defun hydra-head-stale-p (hydra)
    "returns non-nil iff the <hydra> hasn't been touched for too long of a time."
    (< (+ (hydra-head-atime hydra) *hydra-head-timeout*)
       (get-universal-time)))
#+end_src

* handling requests
:PROPERTIES:
:noweb-ref: rpc
:END:
the client may send requests and may cancel requests.  the requests which are accepted must be defined in the software system.  we allow the application pogrammer to register requests and how they should be handled.  when handling a request, the programmer can send answers to the client.  when the request is finished, it is automatically closed.

** performing intercom method call requests
when an intercom request is performed, we receive the request in jso(w)n format.  the necessary information is parsed from the request and the registered request is called.

#+begin_src lisp
  (defun perform-intercom-request (jsown-request)
    "performs an intercom request as described by <jsown-request>."
    (apply #'call-remote-procedure
           (jsown:val jsown-request "rid")
           (jsown:val jsown-request "name")
           (jsown:val jsown-request "args")))
#+end_src

** performing intercom close requests
when a close request is handled, we must remove the rid.  the thread which is executing the request must manually find out whether or not it is still wanted and stop itself when it is safe to do so.

#+begin_src lisp
  (defun perform-close-request (rid)
    "closes the request for the rid."
    (remove-rid rid))
#+end_src


* support code
:PROPERTIES:
:noweb-ref: support
:END:
some handy snippets of code which make some code easier to write.

#+begin_src lisp
  (defun s+ (&rest args)
    "pretty-prints and concatenates the resulting strings of each arg in <args>."
    (format nil "~{~A~}" args))
#+end_src

** assertions
various assertions are used, they're tedious to write manually each time.

#+begin_src lisp
  (defmacro assert-eql-compatible (place)
    "asserts that place is an eql-compatible place.
    this means it must be one of:
    1. a symbol
    2. a character
    3. a number"
    `(assert (or (symbolp ,place)
                 (numberp ,place)
                 (characterp ,place))
             (,place)
             "~A must contain an object which may be eql-compatible when copied.  it contains ~A." ',place ,place))
  
  (defmacro assert-hydra-head (place)
    "asserts that <place> contains a hydra-head"
    `(assert (hydra-head-p ,place)
             (,place)
             "~A must contain an object of type hydra-head.  it contains ~A." ',place ,place))
  
  (defmacro assert-hydra-body (place)
    "asserts that <place> contains a hydra-body"
    `(assert (hydra-body-p ,place)
             (,place)
             "~A must contain an object of type hydra-body.  it contains ~A." ',place ,place))
#+end_src

* bolting together the tangled file
in this section all the code fragments are joined together for the lisp source file(s).

#+begin_src lisp :tangle intercom.lisp
  (in-package :intercom)
  
  <<generic-functions>>
  
  <<support>>
  
  <<data-structures>>
  
  <<hydra>>
  
  <<client-talk>>
  
  <<timeouts>>
  
  <<rpc>>
#+end_src


* some examples

#+begin_src lisp :tangle intercom-examples.lisp
  (defpackage :intercom-examples
    (:use :cl :intercom))
  
  (in-package :intercom-examples)
  
  (define-remote-procedure test (count base diff)
    (loop repeat count
       for time = (+ base (random diff))
       do
         (sleep time)
         (message "bark" time))
    (message "cemetary" "senna died! :`("))
  
  (define-remote-procedure echo (&key string count interval)
    (loop repeat count
       do (sleep (/ interval 1000)) ; we don't have a really good idea how good the sleep works
         (message "value" string))
    (message "ready" :true))
  
  (define-remote-procedure eval (string)
    (message "ready" (eval (read string))))
  
  (defun rand-between (a b)
    "returns a number between min and max"
    (+ (min a b) (random (abs (- a b)))))
  (define-remote-procedure timeout (count min-ms max-ms end-key)
    (let ((start-time (get-internal-real-time)))
      (loop for nr from 0 below count
         for sleepytime = (rand-between (/ min-ms 1000) (/ max-ms 1000))
         do (message "current-time" (jsown:new-js ("count" nr)
                                                  ("timeout" (round (* sleepytime 1000)))
                                                  ("total-time" (round (* (/ (- (get-internal-real-time) start-time)
                                                                             internal-time-units-per-second)
                                                                          1000))))))
      (message end-key "ok")))
#+end_src

we add an asd files to make the loading of the examples a tad easier.

#+begin_src lisp :tangle intercom-examples.asd
  (asdf:defsystem :intercom-examples
    :name "Intercom"
    :author "Aad Versteden <madnificent@gmail.com>"
    :version "0.0.1"
    :maintainer "Aad Versteden <madnificent@gmail.com>"
    :licence "MIT"
    :description "Some example remote procedures for intercom"
    :depends-on (intercom jsown)
    :serial t
    :components ((:file "intercom-examples")))
#+end_src
